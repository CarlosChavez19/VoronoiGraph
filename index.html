<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Exportaciones del Per√∫ hacia el APEC por tipo de producto (US$ millones)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="d3-voronoi-map plugin to remake 'Global Population by Region from 1950 to 2100'">
    <script src="https://d3js.org/d3.v6.min.js" charset="utf-8"></script>
    <script src="https://rawcdn.githack.com/Kcnarf/d3-weighted-voronoi/v1.0.0/build/d3-weighted-voronoi.js"></script>
    <script src="https://rawcdn.githack.com/Kcnarf/d3-voronoi-map/v2.0.0/build/d3-voronoi-map.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <style>
          
      body{
        margin: 0;
        font-family: "Nunito", sans-serif;
      }

      #tooltip {
        position: absolute;
        padding: 5px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 12px;
        pointer-events: none;
        display: none;
      }
      
      #container{
        background-color: #f7f2d7;
        display: flex; 
        flex-wrap: wrap; 
        max-height: 450; 
        width: 100%; 
        align-items: center;
      }
      
      #title {
        font-weight: 700;
        font-size: 100%;
      }
      
      text.tiny {
        font-size: 10pt;
      }
      text.light {
        fill: darkgray
      }
      
      svg{
        display: flex;
        justify-content: center;
        align-items: center;
        margin: auto;
      }

      .symbol {
        fill: none;
        stroke: gray ;
        stroke-width: 14px;
      }
      
      .cell {
        stroke: lightgrey;
        stroke-width: 1px;
      }
      
      .population {
        fill: white;
        text-anchor: middle;
        dominant-baseline: central;
      }
      
      .population-total, .year {
        fill: lightgrey;
        text-anchor: middle;
        font-size: 20px;
        font-weight: 700;
      }
      
      .dashed {
        stroke-dasharray: 2, 4;
      }
      
      
      .remarquable-notes path {
        fill: none;
        stroke: grey;
      }
      
      .remarquable-notes circle {
        fill: grey;
      }
      
      .remarquable-note.year2100>path {
        stroke-dasharray: none;
      }
      
      .legend-color {
        stroke-width: 1px;
        stroke:darkgrey;
      }
      
      .highlighter {
        fill: transparent;
        stroke: none;
      }
      .highlight {
        stroke: white;
        stroke-width: 1px;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <svg xmlns="http://www.w3.org/2000/svg"  preserveAspectRatio="xMaxYMin meet">
      	<defs>
          <filter id="inset-shadow">
            <feGaussianBlur stdDeviation="5" result="offset-blur"></feGaussianBlur>
            <!-- Shadow Blur -->
      			<feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse"></feComposite>
            <!-- Invert the drop shadow to create an inner shadow -->
      			<feFlood flood-color="black" flood-opacity="1" result="color"></feFlood>           	<!-- Color & Opacity -->
      			<feComposite operator="in" in="color" in2="inverse" result="shadow"></feComposite>
            <!-- Clip color inside shadow -->
      			<feComponentTransfer in="shadow" result="shadow">
              <!-- Shadow Opacity -->
          		<feFuncA type="linear" slope=".75"></feFuncA>
      			</feComponentTransfer>
      			<feComposite operator="over" in="shadow" in2="SourceGraphic"></feComposite>
            <!-- Put shadow over original object -->
          </filter>
        </defs>
      </svg>
    </div>
    
    <div id="tooltip"></div>
    
    <script>
      //begin: constants
      var _PI = Math.PI,
      		_2PI = 2*Math.PI,
      		cos = Math.cos,
          sin = Math.sin,
      		sqrt = Math.sqrt;
      var aspectratio = 550/450
      //end: constants
      
      var container = document.querySelector('#container');      


      //begin: raw data global def
      var overallData;
      var selectedData;
      var totalPopulationByYear = {};
      //end: raw data global def
      
      //begin: data-related utils
      function populationAccessor(d){ return d["weight"]; };
      function yearAccesor(d){ return d["exportaciones"];}
      function highlighterGroupId(d){ return "group-"+d.id; };
      //end: data-related utils
      
      //begin: drawing utils
      function liner(poly){ return "M"+poly.join(",")+"z"; };
      //end: drawing utils
      
      //begin: layout conf.
      

      var maxWidth = 550,
          svgWidth = container.getBoundingClientRect().width;
          if (container.getBoundingClientRect().width > maxWidth){
            svgWidth = 550;
          }
      var maxHeight = 450,
          svgHeight = svgWidth/aspectratio;
          if (container.getBoundingClientRect().height > maxHeight){
            svgHeight = 450;
          }

      var height = svgHeight,
          width = svgWidth,
          halfWidth = width/2,
          halfHeight = height/2,
          quarterWidth = width/4,
          quarterHeight = height/4,
          titleY = 20,
          legendsTopY = 70,
          mapCenter = [quarterWidth+40, halfHeight+20];
      //end: layout conf.
      
      //begin: map conf.
      var MaxRadius = 150,

          Radius = MaxRadius * (svgWidth / maxWidth),
          

          minRadius = 80;

      var dataOfYear,
          circlingPolygon,
          simulation,
          polygons;
      // colores del grafico
      var color1 = "#430cb0",
          color2 = "#8822bf";    
      //end: map conf.
      
      //begin: reusable d3Selection
      var svg, drawingArea, mapContainer;
      //end: reusable d3Selection
      
      d3.csv("Exportaciones.csv").then(function(data) {
        data.forEach(function(d) {csvParser(d)});
        overallData = data;
        
        init(overallData);

      });

      //funcion que se encarga de inicializar el mapa dependiendo de la data proporcionada
      function init(data){
        initLayout();
        simulate(data);
      }
      
      //////////////////////////////////////
      // Mechanics involved for animation //
      //////////////////////////////////////
      
      //Inicializacion del mapa
      function simulate(overallData){
        simulation = d3.voronoiMapSimulation(overallData)
          .clip(circlingPolygon)
          .weight(populationAccessor)
        	.convergenceRatio(0.02)
          .on("tick", function() {
          // function called after each iteration of computation
          // called only in simulation mode, not in static mode (see below)
          polygons = simulation.state().polygons;
          redrawMap();
        })
          .on("end", function() {
          attachMouseListener(overallData);
        }); 
        simulation.initialPosition(d3.voronoiMapInitialPositionPie().startAngle(-Math.PI/10));
      }
      
      //////////////////////////////////////
      //          Data management         //
      //////////////////////////////////////

      /*
        Esta funcion lee el csv proporcionado y crea una lista donde guarda
        la infomacion de dicho csv.      
      */
      function csvParser(d) {
          
          d3.range(0,1,1).map(function(){
            d.monto = +d.monto;

            // Modifica los valores de PBI para que se vean mejor en el mapa

            d.weight = d.monto
            if (d.tipo == "tradicional"){
              d.color = color1;
            }
            else {
              d.color = color2;
            }



            });
          d.id = +d.id;
          return d;
        }
      
      //////////////////////////////////////
      //              Drawing             //
      //////////////////////////////////////
      
      //Funcion que se encargar de generar la forma circular del mapa
      function computeCirclingPolygon(radius) {
        var points = 60,
            increment = _2PI/points,
            circlingPolygon = [];
        
        for (var a=0, i=0; i<points; i++, a+=increment) {
          circlingPolygon.push(
            [radius*Math.cos(a), radius*Math.sin(a)]
          )
        }
        
      	return circlingPolygon;
      };
      
      //Funcion que se encarga de inicializar el layout del mapa
      function initLayout() {
        circlingPolygon = computeCirclingPolygon(Radius);
        svg = d3.select("svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);
        
        drawingArea = svg.append("g")
          .attr("width", svgWidth)
          .attr("height", svgHeight)
        	.classed("drawingArea", true);
                
        mapContainer = drawingArea.append("g")
        	.classed("map-container", true)
        	.attr("transform", "translate("+[mapCenter[0],mapCenter[1]-25]+")");

        drawSymbol();
        
        var yearRadius = Radius+5
        
        svg.select("defs")
        	.append("path")
          .attr("d", "M "+[-yearRadius,0]+" A "+yearRadius+" "+yearRadius+" 0 1 1 "+[0, yearRadius])
        	.attr("id", "year_path");

        mapContainer.append("text")
          .append("textPath")
          	.attr("xlink:href", "#year_path")
        		.attr("startOffset", "5%")
          		.append("tspan")
          			.classed("year", true)
        				.attr("transform", "rotate(-45)translate(0,"+(-Radius-6)+")");
        
        mapContainer.append("text")
          .append("textPath")
          	.attr("xlink:href", "#year_path")
        		.attr("startOffset", "40%")
          		.append("tspan")
                .classed("population-total", true)
                .attr("transform", "rotate(45)translate(0,"+(-Radius-6)+")");
        
        mapContainer.append("g")
        	.classed('cells', true);
        mapContainer.append("g")
        	.classed('populations', true);
        mapContainer.append("g")
        	.classed('highlighters', true);

        drawLegends();
        drawTitle();
        drawFooter();
      }
            

      function drawTitle() {
        var maxfontsize = 11,
            fontsize = maxfontsize * (svgWidth / maxWidth);
        drawingArea.append("text")
        	.attr("id", "title")
        	.attr("transform", "translate("+[halfWidth, titleY]+")")
        	.attr("text-anchor", "middle")
          .style("font-size", fontsize +"pt")
          .text("Exportaciones del Per√∫ hacia el APEC por tipo de producto (US$ millones)")
      }
      
      function drawFooter() {
        //Para agregar mas texto solo duplicar lo de abajo y cambiar el texto

        var maxfontsize = 10,
            fontsize = maxfontsize * (svgWidth / maxWidth);

        drawingArea.append("text")
        	.classed("tiny light", true)
        	.attr("transform", "translate("+[0, height-20]+")")
        	.attr("text-anchor", "start")
        	.text("Fuente:  Comex Per√∫, Mincetur")
          .style("font-size", fontsize +"pt")
          .call(wrapText, width);
        drawingArea.append("text")
        	.classed("tiny light", true)
        	.attr("transform", "translate("+[0, height-5]+")")
        	.attr("text-anchor", "start")
        	.text("Elaborado por Laboratorio de periodismo innovador ECData y la UPC")
          .style("font-size", fontsize +"pt")
          .call(wrapText, width);

      function wrapText(text, width) {
          text.each(function() {
              var text = d3.select(this),
                  words = text.text().split(/\s+/).reverse(),
                  word,
                  line = [],
                  lineNumber = 0,
                  lineHeight = 1.1, // ems
                  y = text.attr("y"),
                  dy = parseFloat(text.attr("dy")) || 0,
                  tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
          
              while (word = words.pop()) {
                  line.push(word);
                  tspan.text(line.join(" "));
                  if (tspan.node().getComputedTextLength() > width) {
                      line.pop();
                      tspan.text(line.join(" "));
                      line = [word];
                      tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
                  }
              }
          });
        }
      }
      
      function drawLegends() {
        var maxlegendHeight = 13,
            legendHeight = maxlegendHeight * (svgWidth / maxWidth);

        var colorWidth = legendHeight*4,
            interLegend = 4;

        var maxfontsizelegend = 10,
            fontsizelegend = maxfontsizelegend * (svgWidth / maxWidth);

        var maxfontsizetitle = 14,
            fontsizetitle = maxfontsizetitle * (svgWidth / maxWidth);
        
        var uniqueColors = {};
        var filteredData = overallData.filter(function(d) {
            if (!uniqueColors[d.color]) {
                uniqueColors[d.color] = true;
                return true;
            }
            return false;
        });

        var legendContainer = drawingArea.append("g")
        	.classed("legend", true)
        	.attr("transform", "translate("+[width-15, legendsTopY]+")");
        
        var legends = legendContainer.selectAll(".legend")
        	.data(filteredData)
        	.enter();
        
        var legend = legends.append("g")
        	.classed("legend", true)
        	.attr("transform", function(d,i){
            return "translate("+[0, i*(legendHeight+interLegend)]+")";
          })
        	
        legend.append("rect")
        	.classed("legend-color", true)
        	.attr("filter", "url(#inset-shadow)")
        	.attr("x", -colorWidth)
        	.attr("width", colorWidth)
        	.attr("height", legendHeight)
        	.style("fill", function(d){ return d.color; });
          
        legend.append("text")
        	.classed("tiny", true)
        	.attr("transform", "translate("+[-(colorWidth+5), legendHeight-2]+")")
        	.style("text-anchor", "end")
          .style("font-size", fontsizelegend +"pt")
        	.text(function(d){ return d.tipo; });
        
        legendContainer.append("text")
        	.attr("transform", "translate("+[0, -interLegend]+")")
        	.style("text-anchor", "end")
          .style("font-size", fontsizetitle)
          .text("Leyenda");
      }
      

      //creo que genera un circulo que rodea al mapa, ni idea la vd
      function drawSymbol() {
        var symbol = mapContainer.append("g").classed("symbol", true);
        
        symbol.append("circle")
        	.attr("r", Radius-5);
      }
      
      //Funcion que se encarga de dibujar las celdas del mapa con sus etiquedas
      function redrawMap() {

        var cells = mapContainer.select(".cells")
	        .selectAll(".cell")
        	.data(polygons);
        cells.enter()
        		.append("path")
        			.classed("cell", true)
        		.merge(cells)
        			.attr("filter", "url(#inset-shadow)")
        			.attr("d", liner)
        			.style("fill", function(d){
            		return d.site.originalObject.data.originalData.color;
          		});


        // Etiqueta de poblacion en cada poligono
        var populations = mapContainer.select(".populations")
	        .selectAll(".population")
        	.data(polygons);

        var maxfontsize = 10,
            fontsize = maxfontsize * (svgWidth / maxWidth);

        populations.enter()
        		.append("text")
        		.classed("population", true)
            .style("font-size", 10+"px") //daownscale to preserve fontsize
        		.merge(populations)
        			.attr("transform", function(d){
          			return "translate("+[d.site.x, d.site.y]+")scale("+1+")"; // +6 for vertical centering
        			})
        			.each(function(d) {
                var text = d3.select(this);
                //var value = populationAccessor(d.site.originalObject.data.originalData);
                var year = yearAccesor(d.site.originalObject.data.originalData);
                text.text(""); // Clear any existing text
                text.append("tspan")
                    .text(year)
                    .style("font-size", fontsize +"px")
                    .attr("x", 0)
                    .attr("dy", "0em"); // Adjust the dy value as needed for line spacing
              })



        var highlighters = mapContainer.select(".highlighters")
	        .selectAll(".highlighter")
        	.data(polygons);
        highlighters.enter()
        		.append("path")
        		.merge(highlighters)
        			.attr("class", function(d) {
                return highlighterGroupId(d.site.originalObject.data.originalData);
              })
        			.classed("highlighter", true)
        			.attr("d", liner);
      }
      
      function attachMouseListener(providedData){
        providedData.forEach(function(d) {
        const regionId = d.id;
        d3.selectAll(".group-" + regionId)
          .on("mouseenter", function(event) {
            tooltip.style.display = "block";
            tooltip.innerHTML = providedData[regionId].monto + " US$ millones"; // Cambia el contenido seg√∫n tus datos
            d3.select(".group-" + regionId).classed("highlight", true);
          })
          .on("mousemove", function(event) {
            tooltip.style.left = (event.pageX + 10) + "px";
            tooltip.style.top = (event.pageY + 10) + "px";
          })
          .on("mouseleave", function() {
            tooltip.style.display = "none";
            d3.select(this).classed("highlight", false);
          });
      });
      } 

      // Funci√≥n para recargar el iframe al cambiar el tama√±o de la ventana
      window.addEventListener('resize', function () {
        if(container.getBoundingClientRect().width <= maxWidth || container.getBoundingClientRect().height <= maxHeight){

        
          svgWidth = container.getBoundingClientRect().width;
          svgHeight = svgWidth/aspectratio;
          height = svgHeight,
          width = svgWidth,
          halfWidth = width/2,
          halfHeight = height/2,
          quarterWidth = width/4,
          quarterHeight = height/4,
          titleY = 20,
          legendsTopY = 70,
          mapCenter = [quarterWidth+40, halfHeight+20];

          if(Radius >= minRadius && Radius <= MaxRadius && MaxRadius * (svgWidth / maxWidth) > minRadius && MaxRadius * (svgWidth / maxWidth) <= MaxRadius){

            Radius = MaxRadius * (svgWidth / maxWidth);
          }
        }
        else{
          svgWidth = maxWidth;
          svgHeight = svgWidth/aspectratio;
        }
        
        svg.selectAll("*").remove();
        init(overallData);
      });

      //Funcion que se encarga de mostrar mas informacion de una celda seleccionada redibujando el mapa
      function moreInfo(regionId){
        selectedData = [overallData[regionId]];
        mapContainer.selectAll("*").remove();
        init(selectedData);
      }

      //Funcion que se encarga de resaltar las celdas seleccionadas
      function highlight(regionId, highlight){
        return function() {
          d3.selectAll(".group-" + regionId)
            .classed("highlight", highlight);
        }
      }
    </script>
  </body>
</html>